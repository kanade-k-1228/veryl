use super::Hook;
use crate::Model;
use std::collections::HashMap;
use std::fs::File;
use std::io::{BufWriter, Write};

// Log changes to VCD file, and not to buffer
// this logger consumes less memory, but cannot pre-process waveform data
pub struct VCDLoggerHook {
    writer: Option<BufWriter<File>>,
    signal_ids: HashMap<String, String>, // signal name -> VCD identifier
    last_values: HashMap<String, usize>, // last recorded values
    next_id_char: u8,                    // for generating unique identifiers
    initialized: bool,
}

impl VCDLoggerHook {
    pub fn new(path: &str) -> Self {
        let file = File::create(path).ok();
        let writer = file.map(|f| BufWriter::new(f));

        VCDLoggerHook {
            writer,
            signal_ids: HashMap::new(),
            last_values: HashMap::new(),
            next_id_char: b'!', // Start with ASCII '!'
            initialized: false,
        }
    }

    fn generate_id(&mut self) -> String {
        let id = String::from(char::from(self.next_id_char));
        self.next_id_char += 1;
        // Skip problematic characters
        if self.next_id_char == b'#' || self.next_id_char == b'$' {
            self.next_id_char += 1;
        }
        // Wrap around to multi-character IDs if needed
        if self.next_id_char > b'~' {
            self.next_id_char = b'!';
        }
        id
    }

    fn write_header(&mut self, model: &Model) {
        // Collect signals before borrowing writer
        let signals = self.collect_signals(model);

        // Generate all IDs first
        let mut signal_id_pairs = Vec::new();
        for signal_name in signals.keys() {
            let id = self.generate_id();
            self.signal_ids.insert(signal_name.clone(), id.clone());
            signal_id_pairs.push((signal_name.clone(), id));
        }

        if let Some(ref mut writer) = self.writer {
            // Write VCD header
            writeln!(writer, "$date").ok();
            writeln!(writer, "    Generated by Veryl Simulator").ok();
            writeln!(writer, "$end").ok();

            writeln!(writer, "$version").ok();
            writeln!(writer, "    Veryl Simulator 0.1.0").ok();
            writeln!(writer, "$end").ok();

            writeln!(writer, "$timescale").ok();
            writeln!(writer, "    1ns").ok();
            writeln!(writer, "$end").ok();

            // Define module scope
            writeln!(writer, "$scope module top $end").ok();

            // Register all signals
            for (signal_name, id) in signal_id_pairs {
                writeln!(writer, "$var wire 32 {} {} $end", id, signal_name).ok();
            }

            writeln!(writer, "$upscope $end").ok();
            writeln!(writer, "$enddefinitions $end").ok();

            writer.flush().ok();
        }
    }

    fn write_initial_values(&mut self, model: &Model) {
        // Collect signals before borrowing writer
        let signals = self.collect_signals(model);

        if let Some(ref mut writer) = self.writer {
            writeln!(writer, "$dumpvars").ok();
            for (signal_name, value) in &signals {
                if let Some(id) = self.signal_ids.get(signal_name) {
                    writeln!(writer, "b{:b} {}", value, id).ok();
                    self.last_values.insert(signal_name.clone(), *value);
                }
            }
            writeln!(writer, "$end").ok();

            writer.flush().ok();
        }
    }

    fn write_changes(&mut self, time: u64, model: &Model) {
        // Collect signals before borrowing writer
        let signals = self.collect_signals(model);
        let mut has_changes = false;
        let mut changes = Vec::new();

        // Check for changes
        for (signal_name, value) in &signals {
            let last_value = self.last_values.get(signal_name).copied().unwrap_or(0);
            if *value != last_value {
                has_changes = true;
                if let Some(id) = self.signal_ids.get(signal_name) {
                    changes.push((id.clone(), *value));
                    self.last_values.insert(signal_name.clone(), *value);
                }
            }
        }

        // Write changes to file
        if has_changes {
            if let Some(ref mut writer) = self.writer {
                writeln!(writer, "#{}", time).ok();
                for (id, value) in changes {
                    writeln!(writer, "b{:b} {}", value, id).ok();
                }
                writer.flush().ok();
            }
        }
    }

    fn collect_signals(&self, model: &Model) -> HashMap<String, usize> {
        let mut signals = HashMap::new();

        // Collect all output signals
        // Note: This is limited to outputs accessible via Model::get
        // In a real implementation, we'd want access to all signals

        // Try to collect common signal names
        for signal_name in &["a", "b", "c", "clk", "reset"] {
            if let Some(val) = model.get(signal_name) {
                signals.insert(signal_name.to_string(), val);
            }
        }

        signals
    }
}

impl Hook for VCDLoggerHook {
    fn on_reset(&mut self, time: u64, model: &Model) {
        if !self.initialized {
            self.write_header(model);
            self.write_initial_values(model);
            self.initialized = true;
        }
        self.write_changes(time, model);
    }

    fn post_clock(&mut self, time: u64, _clock_name: &str, model: &Model) {
        if !self.initialized {
            self.write_header(model);
            self.write_initial_values(model);
            self.initialized = true;
        }
        self.write_changes(time, model);
    }

    fn on_finish(&mut self, _time: u64, _model: &Model) {
        if let Some(ref mut writer) = self.writer {
            writer.flush().ok();
        }
    }
}

impl Drop for VCDLoggerHook {
    fn drop(&mut self) {
        if let Some(ref mut writer) = self.writer {
            writer.flush().ok();
        }
    }
}
